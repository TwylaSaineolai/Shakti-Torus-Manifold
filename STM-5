"""
Śakti Torus Manifold (STM) - Enhanced Version
Full standalone implementation with hysteresis, dynamic geometry, and pattern detection
"""

import numpy as np
from dataclasses import dataclass
from typing import List, Dict, DefaultDict
from collections import defaultdict

PHI = (1 + np.sqrt(5)) / 2
TWO_PI = 2 * np.pi

# ---------------------------------------------------------------------
# Canonical Śrī Yantra / Meru base data
# ---------------------------------------------------------------------

EPS = np.deg2rad(1.535)   # ≈ 1.5° temple offset rotation

# Upward (Śiva) triangles – K.C. Arya/Iyer normalized radii
UP_TRIANGLES = [
    np.array([[ 0.000000,  1.000000],
              [-0.866025, -0.500000],
              [ 0.866025, -0.500000]]),
    np.array([[ 0.000000,  0.882900],
              [-0.764050, -0.441450],
              [ 0.764050, -0.441450]]),
    np.array([[ 0.000000,  0.705500],
              [-0.611600, -0.352750],
              [ 0.611600, -0.352750]]),
    np.array([[ 0.000000,  0.578700],
              [-0.501400, -0.289350],
              [ 0.501400, -0.289350]]),
    np.array([[ 0.000000,  0.440600],
              [-0.381600, -0.220300],
              [ 0.381600, -0.220300]])
]

# Downward (Śakti) triangles
DOWN_TRIANGLES = [
    np.array([[ 0.000000, -0.882900],
              [ 0.764050,  0.441450],
              [-0.764050,  0.441450]]),
    np.array([[ 0.000000, -0.705500],
              [ 0.611600,  0.352750],
              [-0.611600,  0.352750]]),
    np.array([[ 0.000000, -0.578700],
              [ 0.501400,  0.289350],
              [-0.501400,  0.289350]]),
    np.array([[ 0.000000, -0.440600],
              [ 0.381600,  0.220300],
              [-0.381600,  0.220300]])
]

MERU_Z = np.array([0.00, 0.15, 0.30, 0.55, 0.80, 0.20, 0.35, 0.60, 0.85])
def sri_yantra_reference_angles():
    """Canonical Śrī Yantra reference angles (Arya/Iyer)."""
    triangles = UP_TRIANGLES + DOWN_TRIANGLES
    centroids = np.array([t.mean(axis=0) for t in triangles])
    return np.arctan2(centroids[:, 1], centroids[:, 0]) % TWO_PI

def sri_meru_coordinates(up_triangles=UP_TRIANGLES, down_triangles=DOWN_TRIANGLES):
    """Return 3‑D Meru‑Yantra vertices with height."""
    all_triangles = up_triangles + down_triangles
    coords3d = []
    for i, tri in enumerate(all_triangles):
        z = MERU_Z[i]
        tri_3d = np.column_stack((tri, np.full(3, z)))
        coords3d.append(tri_3d)
    return coords3d

def draw_meru():
    """Quick 3‑D plot of the Meru‑Yantra for visual check."""
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d.art3d import Poly3DCollection

    tris3d = sri_meru_coordinates()
    fig = plt.figure(figsize=(8, 8))
    ax = fig.add_subplot(111, projection="3d")
    ax.view_init(elev=30, azim=30)

    for tri in tris3d:
        ax.add_collection3d(
            Poly3DCollection([tri], facecolors="gold", edgecolors="black", alpha=0.6)
        )

    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z (Meru height)")
    plt.title("Śrī Meru Yantra – canonical base with rising tiers")
    plt.show()

# ---------------------------------------------------------------------
# Geometry
# ---------------------------------------------------------------------

@dataclass
class STMGeometry:
    n_up: int = 5
    n_down: int = 4
    mode: str = "offset"   # "bindu" = centred (sleep), "offset" = temple (wake)

    def reference_angles(self) -> np.ndarray:
        """Return authentic Sri Yantra reference angles in centred or offset expression."""
        base = sri_yantra_reference_angles()   # always use the authentic geometry
        if self.mode == "bindu":
            # sleep state – bindu‑centred Sri Yantra
            return base
        else:
            # wake state – temple‑offset Sri Yantra (apply global offset)
            return (base + EPS) % TWO_PI


    def element_angles(self) -> np.ndarray:
        """Return angles for the five elements"""
        return self.reference_angles()[:5]

# ---------------------------------------------------------------------
# System definition
# ---------------------------------------------------------------------

@dataclass
class ElementOscillator:
    """Represents a single element oscillator"""
    label: str
    phase: float
    amplitude: float
    freq: float
    base_amp: float
    gating_in: float = 1.0

@dataclass
class SystemState:
    """Current state of the system"""
    phases: np.ndarray
    amps: np.ndarray
    time: float

@dataclass
class EarthGate:
    """Scalar gating parameter that modulates coupling strength"""
    value: float = 1.0
    tau: float = 10.0  # time constant for gate evolution
    
    def update(self, E_coherence: float, dt: float) -> float:
        """Update earth gate based on element coherence"""
        dG = (E_coherence - self.value) / self.tau
        self.value = np.clip(self.value + dG * dt, 0, 1)
        return self.value

class STMSystem:
    def __init__(self, geo_mode="offset", record=True):
        self.n_elements = 5
        self.n_total = self.n_elements
        self.geometry = STMGeometry(mode=geo_mode, n_up=self.n_elements)
        
        # bija‑based element ratios 
        bija_ratios = {
            "Earth": 1.000,   # base
            "Water": 1.125,   # 9/8  (major tone)
            "Fire": 1.250,    # 5/4  (major third)
            "Air": 1.333,     # 4/3  (perfect fourth)
            "Ether": 1.500    # 3/2  (perfect fifth)
        }
        
        # Use bija ratios to define frequencies by scaling from base frequency
        base_freq = 1.0
        self.freq = np.array([base_freq * bija_ratios[label] for label in ["Earth", "Water", "Fire", "Air", "Ether"]])
        
        # Initialize oscillators (5 elements)
        self.oscillators: List[ElementOscillator] = []
        self._initialize_oscillators()
        
        # Coupling matrix (MODIFIED with earth gate - PRESERVED structure)
        self.K = self._build_coupling()
        
        # Earth gate
        self.earth_gate = EarthGate()
        
        # Developmental hysteresis variables (slow coupling memory)
        self.hysteresis_water = 1.0   # Water–Fire coupling multiplier
        self.hysteresis_air = 1.0     # Air–Ether coupling multiplier
        
        # Geometry switching state
        self.last_mode_switch_time = 0.0
        self.mode_switch_refractory = 10.0  # Minimum time between switches
        self.verbose = False  # Default to False to prevent console spam
        
        # Pattern detection tracking
        self.pattern_history = []
        self.pattern_switch_time = 0.0
        self.pattern_refractory = 3.0  # Minimum time between pattern switches (tuned for responsiveness)
        self.pattern_persistence_threshold = 10  # Minimum samples to confirm pattern (dwell-time smoothing)
        self.current_pattern_samples = 0  # Counter for pattern persistence
        self.current_pattern_consistent = None  # Currently consistent pattern
        
        self.time = 0.0
        self.record = record
        self.history = {
            "time": [],
            "coherence_elements": [],
            "earth_gate": [],
            "mean_amplitudes": [],
            "fragmentation": [],
            "recovery_time": [],
            "water_hysteresis": [],
            "air_hysteresis": [],
            "geometry_mode": [],
            "pattern": []
        }
        
        # Development tracking
        self.stable_coherence_history = []
        self.last_recovery_time = 0.0

    def _initialize_oscillators(self):
        """Initialize five-element oscillators with base amplitudes"""
        # Base amplitudes mentioned in original code
        base_amps = [0.1, 0.15, 0.2, 0.25, 0.3]  # Earth to Ether
        for i, (label, base_amp) in enumerate(
            zip(["Earth", "Water", "Fire", "Air", "Ether"], base_amps)
        ):
            self.oscillators.append(
                ElementOscillator(
                    label=label,
                    phase=np.random.uniform(0, TWO_PI),
                    amplitude=base_amp,
                    freq=self.freq[i],
                    base_amp=base_amp
                )
            )

    def _build_coupling(self):
        """Build coupling matrix with element-specific weights"""
        K = np.zeros((self.n_elements, self.n_elements))
        # Strong coupling within Earth group (for stability)
        K[0, 1] = 0.2; K[1, 0] = 0.2  # Earth-Water
        K[1, 2] = 0.15; K[2, 1] = 0.15  # Water-Fire
        K[2, 3] = 0.1; K[3, 2] = 0.1  # Fire-Air
        K[3, 4] = 0.05; K[4, 3] = 0.05  # Air-Ether
        
        # Earth group self-coupling
        for i in range(5):
            K[i, i] = -np.sum(K[i, :])
        return K

    def update_hysteresis(self, dt: float):
        """
        Slowly adjust coupling multipliers based on sustained misalignment.
        This encodes developmental hysteresis: long periods of imbalance weaken couplings,
        making future recovery slower; healthy coherence restores them gradually.
        """
        coherence = self.kuramoto_order()
        rate = 0.005  # hysteresis adaptation rate per time unit

        # If coherence is low, Water–Fire coupling declines toward 0.5
        target_water = 1.0 if coherence > 0.6 else 0.5
        self.hysteresis_water += (target_water - self.hysteresis_water) * rate * dt
        # Clamp hysteresis to [0.5, 1.0]
        self.hysteresis_water = np.clip(self.hysteresis_water, 0.5, 1.0)

        # If coherence is excessively high (rigid synchrony), Air–Ether coupling softens to 0.7
        target_air = 1.0 if coherence < 0.8 else 0.7
        self.hysteresis_air += (target_air - self.hysteresis_air) * rate * dt
        # Clamp hysteresis to [0.5, 1.0]
        self.hysteresis_air = np.clip(self.hysteresis_air, 0.5, 1.0)

    def update_geometry_mode(self):
        """
        Switch system geometry between 'offset' and 'bindu' based on hysteresis thresholds.
        """
        # Check if we're past the refractory period
        if self.time - self.last_mode_switch_time < self.mode_switch_refractory:
            return
            
        # If Water–Fire coupling has eroded strongly, regress to bindu
        if self.hysteresis_water < 0.6 and self.geometry.mode == "offset":
            self.geometry.mode = "bindu"
            self.last_mode_switch_time = self.time
            if self.verbose:
                print(f"→ Geometry collapsed to BINDU at t={self.time:.1f}")

        # If Water–Fire coupling has largely recovered, re-differentiate to offset
        elif self.hysteresis_water > 0.85 and self.geometry.mode == "bindu":
            self.geometry.mode = "offset"
            self.last_mode_switch_time = self.time
            if self.verbose:
                print(f"→ Geometry re-expanded to OFFSET at t={self.time:.1f}")

    def detect_pattern(self, metrics):
        """
        Detect developmental pattern based on current system metrics.
        
        Pattern definitions based on the seven-element developmental model:
        1. Collapse: Earth under-supported
        2. Misalignment: Earth crystallized, restricting Water
        3. Fire overcompensation: Fire overcompensating for misaligned Earth
        4. Water flooding: Water flooding due to collapsed Earth
        5. Air compensation: Air compensating for lack of support
        6. Ether compensation: Ether compensating for earlier weaknesses
        7. Living alignment: Balanced integration
        """
        e = metrics["earth"]
        wf = metrics["water_fire"]
        ae = metrics["air_ether"]
        coh = metrics["coherence"]
        frag = metrics["fragmentation"]
        
        # Pattern 1: Collapse - Earth under-supported, low coherence  
        if e < 0.3 and coh < 0.4:
            return "Pattern 1: collapse"
        
        # Pattern 2: Misalignment - Earth crystallized, Water restricted
        elif 0.3 <= e < 0.5 and wf < 0.7:
            return "Pattern 2: misalignment"
        
        # Pattern 3: Fire overcompensation - Water-Fire imbalance with low Earth
        elif wf > 0.9 and e < 0.5:
            return "Pattern 3: fire overcompensation"
        
        # Pattern 4: Water flooding - Water flooding due to collapsed Earth
        elif wf < 0.6 and e < 0.4:
            return "Pattern 4: water flooding"
        
        # Pattern 5: Air compensation - Air compensating for lack of support
        elif ae < 0.8 and coh < 0.5:
            return "Pattern 5: air compensation"
        
        # Pattern 6: Ether compensation - Ether compensating for earlier weaknesses
        elif ae > 0.9 and coh < 0.5:
            return "Pattern 6: ether compensation"
        
        # Pattern 7: Living alignment - Balanced integration (relaxed criteria)
        # Lower thresholds to catch early signs of recovery
        elif e >= 0.5 and wf >= 0.7 and ae >= 0.7 and coh >= 0.65:
            return "Pattern 7: living alignment"
        
        else:
            return "transitional / indeterminate"

    def detect_current_pattern(self):
        """
        Detect and record the current developmental pattern with dwell-time smoothing.
        """
        # Get current metrics
        metrics = {
            "earth": self.earth_gate.value,
            "water_fire": self.hysteresis_water,
            "air_ether": self.hysteresis_air,
            "coherence": self.kuramoto_order(),
            "fragmentation": self.fragmentation_index()
        }
        
        # Detect the potential pattern
        potential_pattern = self.detect_pattern(metrics)
        
        # Apply dwell-time smoothing
        if self.current_pattern_consistent == potential_pattern:
            # Continue counting samples of the same pattern
            self.current_pattern_samples += 1
        elif potential_pattern != "transitional / indeterminate":
            # Reset counter and start tracking new pattern
            self.current_pattern_consistent = potential_pattern
            self.current_pattern_samples = 1
        else:
            # Reset to transitional when not in a clear pattern
            self.current_pattern_consistent = None
            self.current_pattern_samples = 0
        
        # Only return a pattern if it has persisted for threshold duration
        if (self.current_pattern_consistent is not None and 
            self.current_pattern_samples >= self.pattern_persistence_threshold):
            final_pattern = self.current_pattern_consistent
        elif potential_pattern != "transitional / indeterminate":
            # Still consider the potential pattern but mark as unstable
            final_pattern = potential_pattern
        else:
            final_pattern = "transitional / indeterminate"
        
        # Check if we're past the pattern refractory period
        if self.time - self.pattern_switch_time < self.pattern_refractory:
            # Return previous pattern if within refractory period
            if self.pattern_history:
                return self.pattern_history[-1]
            else:
                return "transitional / indeterminate"
        
        # Update pattern history if pattern changed significantly
        if not self.pattern_history or final_pattern != self.pattern_history[-1]:
            self.pattern_switch_time = self.time
            self.pattern_history.append(final_pattern)
            
        # For continuous tracking, always return current pattern  
        return final_pattern

    def _update_oscillators(self, dt: float):
        """Update all oscillators with coupled phase and amplitude dynamics"""
        # Store current values
        phases = np.array([osc.phase for osc in self.oscillators])
        amplitudes = np.array([osc.amplitude for osc in self.oscillators])
        base_amps = np.array([osc.base_amp for osc in self.oscillators])
        
        # Calculate coupling terms with earth gate applied
        phase_coupling = np.zeros(self.n_elements)
        amp_coupling = np.zeros(self.n_elements)
        
        # Apply the gate to coupling strength
        gated_K = self.K * self.earth_gate.value
        
        # Apply slow hysteresis multipliers to selected couplings
        gated_K[1, 2] *= self.hysteresis_water   # Water–Fire link
        gated_K[2, 1] *= self.hysteresis_water

        gated_K[3, 4] *= self.hysteresis_air     # Air–Ether link
        gated_K[4, 3] *= self.hysteresis_air
        
        for i in range(self.n_elements):
            # Phase coupling (Kuramoto-type)
            for j in range(self.n_elements):
                phase_coupling[i] += gated_K[i, j] * amplitudes[j] * np.sin(phases[j] - phases[i])
                
            # Amplitude coupling (diffusion)
            for j in range(self.n_elements):
                amp_coupling[i] += gated_K[i, j] * (amplitudes[j] - amplitudes[i])
        
        # Parameters for amplitude dynamics (with tuned values)
        alpha = 0.3  # self-regulation rate
        beta = 0.2   # coupling diffusion rate
        
        # Update phases and amplitudes
        for i, osc in enumerate(self.oscillators):
            # Phase update (Kuramoto base)
            osc.phase = (osc.phase + TWO_PI * osc.freq + phase_coupling[i] * dt) % TWO_PI
            
            # Amplitude update (with gating and coupling)
            dA = alpha * (base_amps[i] - osc.amplitude) + beta * amp_coupling[i]
            (osc.amplitude) = np.clip(osc.amplitude + dA * dt, 0.0, 1.0)

    def step(self, dt):
        """Perform one time step of the simulation"""
        # Update oscillators
        self._update_oscillators(dt)

        # Update earth gate based on element coherence
        element_coherence = self.kuramoto_order()
        self.earth_gate.update(element_coherence, dt)

        # Update slow hysteresis variables
        self.update_hysteresis(dt)

        # Update geometry mode based on hysteresis
        self.update_geometry_mode()

        self.time += dt

    def kuramoto_order(self) -> float:
        """Calculate order parameter for elements (Earth to Ether)"""
        phases = np.array([osc.phase for osc in self.oscillators])
        return np.abs(np.mean(np.exp(1j * phases)))

    def element_coherence(self, element_idx: int) -> float:
        """Calculate coherence for a single element"""
        phase = self.oscillators[element_idx].phase
        return np.abs(np.mean(np.exp(1j * phase))) if not np.isnan(phase) else 0.0

    def mean_amplitude(self) -> float:
        """Calculate mean amplitude across all elements"""
        return np.mean([osc.amplitude for osc in self.oscillators])

    def fragmentation_index(self) -> float:
        """Calculate the stability fragmentation index"""
        phases = np.array([osc.phase for osc in self.oscillators])
        # Correct way to handle phase differences: wrap into [-π, π]
        diff_phases = np.angle(np.exp(1j * np.diff(phases)))
        # Normalize the fragmentation (standard deviation over π)
        return np.std(diff_phases) / np.pi

    def record_state(self):
        """Record current system state"""
        if not self.record:
            return
            
        coherence = self.kuramoto_order()
        self.history["time"].append(self.time)
        self.history["coherence_elements"].append(coherence)
        self.history["earth_gate"].append(self.earth_gate.value)
        self.history["mean_amplitudes"].append(self.mean_amplitude())
        self.history["fragmentation"].append(self.fragmentation_index())
        
        # Update recovery time tracking
        if len(self.stable_coherence_history) > 0:
            if coherence > 0.7 and self.stable_coherence_history[-1] <= 0.7:
                self.last_recovery_time = self.time
        self.stable_coherence_history.append(coherence)
        
        self.history["recovery_time"].append(self.last_recovery_time)
        
        # Record hysteresis variables
        self.history["water_hysteresis"].append(self.hysteresis_water)
        self.history["air_hysteresis"].append(self.hysteresis_air)
        
        # Record geometry mode
        self.history["geometry_mode"].append(self.geometry.mode)
        
        # Detect and record current pattern
        current_pattern = self.detect_current_pattern()
        self.history["pattern"].append(current_pattern)

    def run(self, t_end=50, dt=0.01, sample_every=10):
        """Run the simulation for specified time"""
        steps = int(t_end / dt)
        for k in range(steps):
            self.step(dt)
            if k % sample_every == 0:
                self.record_state()
        return self

# ---------------------------------------------------------------------
# Reporting / Demo
# ---------------------------------------------------------------------

def summarize(stm, label):
    """Print readable results matching paper structure."""
    print(f"\n───────────────────────────────")
    print(f"{label.upper()} GEOMETRY RESULTS")
    print(f"───────────────────────────────")
    print(f"Bhūmi – Geometric Alignment Stability:")
    print(f"  Final alignment index     = {stm.history['earth_gate'][-1]:.3f}")

    print(f"\nŚrī – Golden‑Angle Symmetry:")
    print(f"  Rotational variance of phases = {np.var([osc.phase for osc in stm.oscillators]):.3f}")

    print(f"\nTārā – Hierarchical Timescales (subgroup coherences):")
    print(f"  Elements : {stm.history['coherence_elements'][-1]:.3f}")
    print(f"  Global   : {stm.history['coherence_elements'][-1]:.3f}")

    print(f"\nSarasvatī – Resonant Harmonic Attraction:")
    print(f"  Earth gate value: {stm.history['earth_gate'][-1]:.3f}")
    print(f"  Water hysteresis: {stm.history['water_hysteresis'][-1]:.3f}")
    print(f"  Air hysteresis: {stm.history['air_hysteresis'][-1]:.3f}")
    print(f"  Final geometry mode: {stm.history['geometry_mode'][-1]}")
    print(f"  Final pattern: {stm.history['pattern'][-1]}")
    
    # Just checking basic coherence
    print(f"───────────────────────────────\n")


def demo():
    """Run a demo of the enhanced STM system"""
    print("ŚAKTI TORUS MANIFOLD SIMULATION (ENHANCED WITH HYSTERESIS, DYNAMIC GEOMETRY, AND PATTERN DETECTION)\n")

    # Run longer simulation as requested
    stm_wake = STMSystem("offset")
    stm_wake.run(t_end=2000)  # Increased to 2000 units for better pattern evolution
    summarize(stm_wake, "offset‑triangle (waking)")

    stm_sleep = STMSystem("bindu")
    stm_sleep.run(t_end=2000)  # Increased to 2000 units for better pattern evolution
    summarize(stm_sleep, "bindu‑centered (sleep)")

    print("Simulation complete.\n")
    return stm_wake, stm_sleep


def plot_evolution(stm):
    """Plot the developmental evolution of key variables"""
    import matplotlib.pyplot as plt
    
    # Only import matplotlib if the function is called
    try:
        plt.style.use('seaborn-v0_8')
    except:
        pass  # If seaborn is not available, proceed with defaults
        
    t = np.array(stm.history["time"])
    
    fig, axes = plt.subplots(3, 2, figsize=(15, 12))
    
    # Coherence and hysteresis
    axes[0,0].plot(t, stm.history["coherence_elements"], label="Coherence", color='blue')
    axes[0,0].set_ylabel("Coherence")
    axes[0,0].set_xlabel("Time")
    axes[0,0].legend()
    axes[0,0].grid(True, alpha=0.3)
    
    # Hysteresis variables
    axes[0,1].plot(t, stm.history["water_hysteresis"], label="Water-Fire", color='green')
    axes[0,1].plot(t, stm.history["air_hysteresis"], label="Air-Ether", color='orange')
    axes[0,1].set_ylabel("Hysteresis")
    axes[0,1].set_xlabel("Time")
    axes[0,1].legend()
    axes[0,1].grid(True, alpha=0.3)
    
    # Earth gate
    axes[1,0].plot(t, stm.history["earth_gate"], label="Earth Gate", color='purple')
    axes[1,0].set_ylabel("Earth Gate")
    axes[1,0].set_xlabel("Time")
    axes[1,0].legend()
    axes[1,0].grid(True, alpha=0.3)
    
    # Geometry mode
    # Plot as a line: 1.0 for offset, 1.2 for bindu
    mode_line = [1.0 if m == "offset" else 1.2 for m in stm.history["geometry_mode"]]
    axes[1,1].plot(t, mode_line, color='gray', linewidth=1)
    axes[1,1].set_ylabel("Geometry Mode")
    axes[1,1].set_xlabel("Time")
    axes[1,1].set_ylim(0.9, 1.3)
    axes[1,1].set_yticks([1.0, 1.2])
    axes[1,1].set_yticklabels(['offset', 'bindu'])
    axes[1,1].grid(True, alpha=0.3)
    axes[1,1].set_xlim(0, max(t) if max(t) > 0 else 1)  # Fix axis range bug
    
    # Pattern timeline
    unique_patterns = list(dict.fromkeys(stm.history["pattern"]))
    pattern_colors = {
        "Pattern 1: collapse": 'red',
        "Pattern 2: misalignment": 'orange',
        "Pattern 3: fire overcompensation": 'brown',
        "Pattern 4: water flooding": 'blue',
        "Pattern 5: air compensation": 'cyan',
        "Pattern 6: ether compensation": 'magenta',
        "Pattern 7: living alignment": 'green',
        "transitional / indeterminate": 'gray'
    }
    
    # Sort patterns by numeric order for consistent vertical positioning
    pattern_order = {
        "Pattern 1: collapse": 1,
        "Pattern 2: misalignment": 2,
        "Pattern 3: fire overcompensation": 3,
        "Pattern 4: water flooding": 4,
        "Pattern 5: air compensation": 5,
        "Pattern 6: ether compensation": 6,
        "Pattern 7: living alignment": 7,
        "transitional / indeterminate": 8
    }
    
    # Create pattern positions with proper sorting
    sorted_patterns = sorted(unique_patterns, key=lambda p: pattern_order.get(p, 999))
    
    # Plot each pattern as a horizontal bar
    for i, pattern in enumerate(sorted_patterns):
        if pattern in pattern_colors:
            color = pattern_colors[pattern]
        else:
            color = 'gray'
            
        mask = np.array(stm.history["pattern"]) == pattern
        if np.any(mask):
            axes[2,0].scatter(t[mask], [i+1]*np.sum(mask), c=color, label=pattern, s=5)
    
    axes[2,0].set_ylabel("Patterns")
    axes[2,0].set_xlabel("Time")
    axes[2,0].set_ylim(0, len(sorted_patterns)+1)
    axes[2,0].set_yticks(range(1, len(sorted_patterns)+1))
    axes[2,0].set_yticklabels(sorted_patterns)
    axes[2,0].grid(True, alpha=0.3)
    
    # Amplitude spread
    amplitudes = np.array(stm.history["mean_amplitudes"])
    axes[2,1].plot(t, amplitudes, color='darkgreen')
    axes[2,1].set_ylabel("Mean Amplitude")
    axes[2,1].set_xlabel("Time")
    axes[2,1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()


def analyze_patterns(stm):
    """Analyze and report pattern distribution and transitions"""
    print(f"\n--- PATTERN ANALYSIS ---")
    print(f"Total simulation time: {stm.time:.1f}")
    
    # Count pattern occurrences
    pattern_counts = defaultdict(int)
    pattern_times = defaultdict(list)
    
    for i, pattern in enumerate(stm.history["pattern"]):
        pattern_counts[pattern] += 1
        pattern_times[pattern].append(stm.history["time"][i])
    
    # Calculate dwell times in each pattern
    dwell_times = {}
    current_pattern = None
    start_time = 0
    
    for i, (time, pattern) in enumerate(zip(stm.history["time"], stm.history["pattern"])):
        if current_pattern != pattern:
            if current_pattern is not None:
                dwell_times[current_pattern] = dwell_times.get(current_pattern, 0) + (time - start_time)
            current_pattern = pattern
            start_time = time
    
    # Add last period
    if current_pattern is not None:
        dwell_times[current_pattern] = dwell_times.get(current_pattern, 0) + (stm.time - start_time)
    
    print(f"\nPattern Distribution:")
    for pattern, count in pattern_counts.items():
        time_ratio = dwell_times.get(pattern, 0) / stm.time * 100 if stm.time > 0 else 0
        print(f"  {pattern}: {count} samples, {time_ratio:.1f}% of time")
    
    # Show transition sequences
    print(f"\nTransition Analysis:")
    transitions = []
    prev_pattern = None
    for pattern in stm.history["pattern"]:
        if prev_pattern and prev_pattern != pattern:
            transitions.append(f"{prev_pattern} → {pattern}")
        prev_pattern = pattern
    
    unique_transitions = list(dict.fromkeys(transitions))  # Remove duplicates
    
    # Safeguard for empty transitions
    if unique_transitions:
        for transition in unique_transitions[:10]:
            print(f"  {transition}")
        if len(unique_transitions) > 10:
            print(f"  ... (and {len(unique_transitions) - 10} more unique transitions)")
    else:
        print("  (no transitions detected)")
    
    print("---\n")
    
    # Return structured data for programmatic use
    return {
        "pattern_counts": dict(pattern_counts),
        "dwell_times": dwell_times,
        "unique_transitions": unique_transitions
    }


def export_pattern_time_series(stm, filename="pattern_time_series.csv"):
    """Export pattern time series data for external analysis"""
    import pandas as pd
    
    df = pd.DataFrame({
        'time': stm.history['time'],
        'pattern': stm.history['pattern'],
        'coherence': stm.history['coherence_elements'],
        'earth_gate': stm.history['earth_gate'],
        'water_hysteresis': stm.history['water_hysteresis'],
        'air_hysteresis': stm.history['air_hysteresis']
    })
    
    df.to_csv(filename, index=False)
    print(f"Pattern time series exported to {filename}")
    return df


if __name__ == "__main__":
    stm_wake, stm_sleep = demo()
    
    # Run analysis on the wake simulation
    analysis_results = analyze_patterns(stm_wake)
    
    # Export pattern series for transition graph analysis
    export_pattern_time_series(stm_wake, "wake_pattern_series.csv")
    export_pattern_time_series(stm_sleep, "sleep_pattern_series.csv")
    
    # Create visualization
    plot_evolution(stm_wake)

# Draw the 3‑D Meru to verify geometry visually
draw_meru()
